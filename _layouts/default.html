{% case site.color-scheme %}
  {% when "", nil, false, 0, empty %}
    {% assign ColorScheme = "auto" %}
  {% else %}
    {% assign ColorScheme = site.color-scheme %}
{% endcase %}

<!DOCTYPE html>
<html lang="{{ site.lang | default: "en-US" }}">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#00838f">
    {% seo %}
    <link rel="stylesheet" href="{{ "/assets/css/colors-ColorScheme.css?v=" | replace: "ColorScheme", ColorScheme | append: site.github.build_revision | relative_url }}">
    <link rel="stylesheet" href="{{ "/assets/css/style.css?v=" | append: site.github.build_revision | relative_url }}">
    <link rel="preload" href="{{site.logo | relative_url}}" as="image">
    <!-- Roboto font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    {% include head-custom.html %}
  </head>
  <body>
    <!-- Header (Turing style) -->
    <header class="site-header">
      <div class="header-container">
        <div class="header-brand">
          {% if site.logo %}
            <a href="{{ "/" | absolute_url }}" class="logo-link">
              <img src="{{ site.logo | relative_url }}" alt="{{ site.title | default: site.github.repository_name }}" class="site-logo" />
            </a>
          {% endif %}
          <div class="site-title">
            <h1><a href="{{ "/" | absolute_url }}">{{ site.title | default: site.github.repository_name }}</a></h1>
          </div>
        </div>
        <nav class="main-navigation" role="navigation" aria-label="Main navigation">
          {%- include navigation.html -%}
        </nav>
        <button class="mobile-menu-toggle" aria-label="Toggle menu" aria-expanded="false">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
    </header>

    <!-- Mobile Menu -->
    <div class="mobile-menu" role="navigation" aria-label="Mobile navigation">
      {%- include navigation.html -%}
    </div>

    <!-- Hero Section (Turing style) -->
    {% if page.hero_title or page.title %}
    <section class="hero-section header__basic bg--light-grey">
      <!-- Animated Graph Background -->
      <div class="hero-graph-container">
        <canvas id="heroGraph" class="hero-graph"></canvas>
      </div>
      
      <div class="hero-content">
        {% if page.breadcrumb %}
        <div class="hero-breadcrumb">
          <nav aria-label="Breadcrumb">
            {% for crumb in page.breadcrumb %}
              {% if crumb.active %}
                <span class="current-page">{{ crumb.text }}</span>
              {% else %}
                <a href="{{ crumb.url }}">{{ crumb.text }}</a>
                {% unless forloop.last %}<span class="breadcrumb-separator">></span>{% endunless %}
              {% endif %}
            {% endfor %}
          </nav>
        </div>
        {% endif %}
        <h1 class="hero-title">{{ page.hero_title | default: page.title }}</h1>
        {% if page.hero_description %}
          <p class="hero-subtitle">{{ page.hero_description }}</p>
        {% endif %}
      </div>
    </section>
    {% endif %}

    <!-- Main Content Layout (Turing style two-column) -->
    <div class="page-wrapper">
      <div class="page-container">
        <main class="main-content">
          {{ content }}
        </main>
        
        <aside class="sidebar">
          {% if page.layout != 'home' %}
            <div class="sidebar-section">
              <h3>On this page</h3>
              <nav class="page-toc" aria-label="Page contents">
                <!-- Table of contents would be generated by JS -->
                <ul class="toc-list">
                  <!-- This would be populated by JavaScript -->
                </ul>
              </nav>
            </div>
          {% endif %}
          
          {% if site.platforms %}
            <div class="sidebar-section">
              <h3>Connect</h3>
              <div class="platform-links">
                {% for platform in site.platforms %}
                  <a href="{{ platform[1] }}" target="_blank" rel="noopener" class="platform-link">
                    <i class="{{ platform[0] | prepend: 'fab fa-' }}"></i>
                    {{ platform[0] | capitalize }}
                  </a>
                {% endfor %}
              </div>
            </div>
          {% endif %}
          
          {% if page.related_links %}
            <div class="sidebar-section">
              <h3>Related</h3>
              <ul class="related-links">
                {% for link in page.related_links %}
                  <li><a href="{{ link.url }}">{{ link.title }}</a></li>
                {% endfor %}
              </ul>
            </div>
          {% endif %}
        </aside>
      </div>
    </div>

    <!-- Footer -->
    <footer class="site-footer">
      <div class="footer-container">
        {%- include footer.html -%}
      </div>
    </footer>
    
    <script src="{{ "/assets/js/scale.fix.js" | relative_url }}"></script>
    <script>
      // Mobile menu toggle
      const menuToggle = document.querySelector('.mobile-menu-toggle');
      const mobileMenu = document.querySelector('.mobile-menu');
      
      if (menuToggle && mobileMenu) {
        menuToggle.addEventListener('click', function() {
          const isExpanded = this.getAttribute('aria-expanded') === 'true';
          this.setAttribute('aria-expanded', !isExpanded);
          this.classList.toggle('active');
          mobileMenu.classList.toggle('active');
          document.body.classList.toggle('menu-open');
        });
      }
      
      // Simple table of contents generator
      function generateTOC() {
        const headings = document.querySelectorAll('.main-content h2, .main-content h3, .main-content h4');
        const tocList = document.querySelector('.toc-list');
        
        if (headings.length > 0 && tocList) {
          headings.forEach((heading, index) => {
            // Add ID to heading if it doesn't have one
            if (!heading.id) {
              heading.id = 'heading-' + index;
            }
            
            const li = document.createElement('li');
            const link = document.createElement('a');
            link.href = '#' + heading.id;
            link.textContent = heading.textContent;
            link.className = 'toc-link toc-' + heading.tagName.toLowerCase();
            li.appendChild(link);
            tocList.appendChild(li);
          });
        } else if (tocList && headings.length === 0) {
          // Hide TOC section if no headings
          const tocSection = tocList.closest('.sidebar-section');
          if (tocSection) tocSection.style.display = 'none';
        }
      }
      
      // Initialize all components when page loads
      document.addEventListener('DOMContentLoaded', function() {
        generateTOC();
        initHeroGraph();
      });
      function initHeroGraph() {
        const canvas = document.getElementById('heroGraph');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        let animationId;
        let time = 0;
        
        // Set canvas size
        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
        }
        
        // Network nodes
        const nodes = [];
        const numNodes = 25;
        
        // Initialize nodes
        function initNodes() {
          nodes.length = 0;
          for (let i = 0; i < numNodes; i++) {
            nodes.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: (Math.random() - 0.5) * 0.3, // Much slower velocity
              vy: (Math.random() - 0.5) * 0.3,
              radius: 3 + Math.random() * 4,
              pulsePhase: Math.random() * Math.PI * 2,
              connections: []
            });
          }
          
          // Create connections between nearby nodes
          nodes.forEach((node, i) => {
            nodes.forEach((otherNode, j) => {
              if (i !== j) {
                const distance = Math.sqrt(
                  Math.pow(node.x - otherNode.x, 2) + 
                  Math.pow(node.y - otherNode.y, 2)
                );
                // Connect nodes that are close enough
                if (distance < 150 && Math.random() > 0.6) { // Increased connection probability
                  node.connections.push(j);
                }
              }
            });
          });
          
          // Ensure all nodes have at least 2 connections
          nodes.forEach((node, i) => {
            if (node.connections.length < 2) {
              // Find the closest nodes that aren't already connected
              const availableNodes = nodes
                .map((otherNode, j) => ({
                  index: j,
                  distance: i !== j ? Math.sqrt(
                    Math.pow(node.x - otherNode.x, 2) + 
                    Math.pow(node.y - otherNode.y, 2)
                  ) : Infinity
                }))
                .filter(item => item.index !== i && !node.connections.includes(item.index))
                .sort((a, b) => a.distance - b.distance);
              
              // Connect to the closest available nodes
              const connectionsNeeded = 2 - node.connections.length;
              for (let k = 0; k < Math.min(connectionsNeeded, availableNodes.length); k++) {
                node.connections.push(availableNodes[k].index);
                // Also add the reverse connection for mutual connection
                nodes[availableNodes[k].index].connections.push(i);
              }
            }
          });
          
          // Remove duplicate connections
          nodes.forEach(node => {
            node.connections = [...new Set(node.connections)];
          });
        }
        
        function animate() {
          if (!canvas.width || !canvas.height) return;
          
          // Clear canvas with very subtle background
          ctx.fillStyle = 'rgba(248, 249, 250, 0.02)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Update node positions (very slow movement)
          nodes.forEach(node => {
            node.x += node.vx;
            node.y += node.vy;
            
            // Bounce off edges
            if (node.x <= node.radius || node.x >= canvas.width - node.radius) {
              node.vx *= -1;
            }
            if (node.y <= node.radius || node.y >= canvas.height - node.radius) {
              node.vy *= -1;
            }
            
            // Keep within bounds
            node.x = Math.max(node.radius, Math.min(canvas.width - node.radius, node.x));
            node.y = Math.max(node.radius, Math.min(canvas.height - node.radius, node.y));
          });
          
          // Draw connections (edges)
          ctx.strokeStyle = 'rgba(0, 131, 143, 0.15)'; // Very subtle teal
          ctx.lineWidth = 1;
          
          nodes.forEach((node, i) => {
            node.connections.forEach(connectionIndex => {
              const connectedNode = nodes[connectionIndex];
              if (connectedNode) {
                const distance = Math.sqrt(
                  Math.pow(node.x - connectedNode.x, 2) + 
                  Math.pow(node.y - connectedNode.y, 2)
                );
                
                // Only draw connection if nodes are still close enough
                if (distance < 180) {
                  // Fade edge based on distance
                  const alpha = Math.max(0, (180 - distance) / 180) * 0.15;
                  ctx.strokeStyle = `rgba(0, 131, 143, ${alpha})`;
                  
                  ctx.beginPath();
                  ctx.moveTo(node.x, node.y);
                  ctx.lineTo(connectedNode.x, connectedNode.y);
                  ctx.stroke();
                }
              }
            });
          });
          
          // Draw nodes
          nodes.forEach(node => {
            // Subtle pulsing effect (much slower)
            const pulseSize = 1 + Math.sin(time * 0.01 + node.pulsePhase) * 0.2;
            const radius = node.radius * pulseSize;
            
            // Node fill with better contrast
            ctx.fillStyle = 'rgba(71, 18, 107, 0.25)'; // More visible purple
            ctx.beginPath();
            ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Node border for better definition
            ctx.strokeStyle = 'rgba(71, 18, 107, 0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Small highlight for depth
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(node.x - radius * 0.3, node.y - radius * 0.3, radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
          });
          
          time += 0.5; // Much slower time progression
          animationId = requestAnimationFrame(animate);
        }
        
        // Initialize
        resizeCanvas();
        initNodes();
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
          resizeCanvas();
          initNodes(); // Reinitialize nodes for new canvas size
        });
        
        // Clean up animation when page unloads
        window.addEventListener('beforeunload', () => {
          if (animationId) cancelAnimationFrame(animationId);
        });
      }
    </script>
  </body>
</html>
